<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/phys/view/PhysViewerApp.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/phys/view/PhysViewerApp.java" />
              <option name="originalContent" value="package phys.view;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import javafx.animation.AnimationTimer;&#10;import javafx.application.Application;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Point3D;&#10;import javafx.scene.*;&#10;import javafx.scene.control.Label;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.input.PickResult;&#10;import javafx.scene.layout.StackPane;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.paint.PhongMaterial;&#10;import javafx.scene.shape.Box;&#10;import javafx.scene.shape.Cylinder;&#10;import javafx.scene.shape.Shape3D;&#10;import javafx.scene.shape.Sphere;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.transform.Rotate;&#10;import javafx.stage.Stage;&#10;import phys.collision.AABB;&#10;import phys.collision.Plane;&#10;import phys.core.RigidBody;&#10;import phys.core.World;&#10;import phys.math.Vec3;&#10;&#10;/**&#10; * Viewer 3D para inspecionar a simulação física.&#10; * &lt;p&gt;&#10; * Funcionalidades:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Câmera orbital (LMB arrasta), zoom (scroll), pan (Shift + arrastar)&lt;/li&gt;&#10; *   &lt;li&gt;Grid xadrez no chão e eixos XYZ&lt;/li&gt;&#10; *   &lt;li&gt;HUD com FPS/ajuda&lt;/li&gt;&#10; *   &lt;li&gt;Cor dos corpos muda quando entram em sleep&lt;/li&gt;&#10; *   &lt;li&gt;Teclas: R reset | Espaço empurra esfera | G mostra/esconde grid&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; */&#10;public class PhysViewerApp extends Application {&#10;&#10;    /** Escala de conversão: 1 metro = 100 pixels. */&#10;    private static final double M2PX = 100.0;&#10;&#10;    /** Mapeamento entre corpos físicos e seus nós visuais. */&#10;    private final Map&lt;RigidBody, Node&gt; nodes = new HashMap&lt;&gt;();&#10;    /** Mundo físico da simulação. */&#10;    private World world;&#10;    /** Grupo raiz dos objetos 3D. */&#10;    private Group worldGroup;&#10;    /** Câmera principal da cena. */&#10;    private PerspectiveCamera cam;&#10;&#10;    // câmera orbital&#10;    private final Rotate camRX = new Rotate(-30, Rotate.X_AXIS);&#10;    private final Rotate camRY = new Rotate(35, Rotate.Y_AXIS);&#10;    private double camDist = 900; // px&#10;    private double camTX = 0, camTY = 80; // pan&#10;    private double lastX, lastY;&#10;    private boolean panning = false;&#10;&#10;    // grid (para toggle)&#10;    private Node gridNode;&#10;&#10;    // HUD&#10;    private Label hud;&#10;    private double fpsTime = 0;&#10;    private int fpsFrames = 0;&#10;&#10;    private SubScene sub;&#10;    // velocidade inicial (m/s) e raio/massa da esfera arremessada&#10;    private static final double THROW_SPEED = 6.0;&#10;    private static final double THROW_RADIUS = 0.15;&#10;    private static final double THROW_MASS = 0.5;&#10;&#10;    @Override&#10;    public void start(Stage stage) {&#10;        setupWorld();&#10;&#10;        worldGroup = new Group();&#10;        buildSceneNodes();&#10;&#10;        // chão + grid + eixos&#10;        gridNode = makeGroundChecker(20, 20, 0.5); // 20x20 quadros de 0.5m&#10;        worldGroup.getChildren().add(gridNode);&#10;        worldGroup.getChildren().add(makeAxes(2.0)); // eixos de 2m&#10;&#10;        // luzes&#10;        var key = new PointLight(Color.WHITE);&#10;        key.setTranslateX(600);&#10;        key.setTranslateY(-800);&#10;        key.setTranslateZ(-600);&#10;        var amb = new AmbientLight(Color.color(0.35, 0.35, 0.4));&#10;        worldGroup.getChildren().addAll(key, amb);&#10;&#10;        // SubScene 3D&#10;        sub = new SubScene(worldGroup, 1280, 720, true, SceneAntialiasing.BALANCED);&#10;        sub.setFill(Color.web(&quot;#0c0f14&quot;));&#10;&#10;        cam = new PerspectiveCamera(true);&#10;        cam.setFieldOfView(45);&#10;        cam.setNearClip(0.05);&#10;        cam.setFarClip(20000);&#10;        sub.setCamera(cam);&#10;        updateCameraTransform();&#10;&#10;        // HUD&#10;        hud = new Label(helpText(&quot;FPS: --.- | Grid: ON&quot;));&#10;        hud.setTextFill(Color.web(&quot;#e6eef7&quot;));&#10;        hud.setFont(Font.font(&quot;Consolas&quot;, 14));&#10;        hud.setPadding(new Insets(8));&#10;        StackPane root = new StackPane(sub, hud);&#10;        StackPane.setAlignment(hud, javafx.geometry.Pos.TOP_LEFT);&#10;&#10;        Scene scene = new Scene(root);&#10;        stage.setTitle(&quot;Physics 3D Viewer&quot;);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;&#10;        // ===== Interações =====&#10;        sub.setOnScroll(e -&gt; { camDist = clamp(camDist - e.getDeltaY(), 120, 4000); updateCameraTransform(); });&#10;        sub.setOnMousePressed(e -&gt; { lastX = e.getSceneX(); lastY = e.getSceneY(); panning = e.isShiftDown(); });&#10;        sub.setOnMouseDragged(e -&gt; {&#10;            double dx = e.getSceneX() - lastX, dy = e.getSceneY() - lastY;&#10;            lastX = e.getSceneX(); lastY = e.getSceneY();&#10;            if (panning) {&#10;                camTX += dx * (camDist / 800.0);&#10;                camTY += dy * (camDist / 800.0);&#10;            } else {&#10;                camRY.setAngle(camRY.getAngle() - dx * 0.25);&#10;                camRX.setAngle(clamp(camRX.getAngle() + dy * 0.25, -85, 85));&#10;            }&#10;            updateCameraTransform();&#10;        });&#10;&#10;        scene.setOnKeyPressed(e -&gt; {&#10;            switch (e.getCode()) {&#10;                case R -&gt; resetWorld();&#10;                case SPACE -&gt; giveSpherePush();&#10;                case G -&gt; toggleGridVisibility();&#10;            }&#10;        });&#10;&#10;        // **Clique direito**: arremessar esfera para o ponto clicado&#10;        sub.setOnMouseClicked(e -&gt; {&#10;            if (e.getButton() == javafx.scene.input.MouseButton.SECONDARY) {&#10;                throwSphereFromClick(e); // usa e.getPickResult()&#10;            }&#10;        });&#10;&#10;        // loop 60Hz&#10;        AnimationTimer timer = new AnimationTimer() {&#10;            long lastNanos = -1;&#10;            double acc = 0.0;&#10;            @Override&#10;            public void handle(long now) {&#10;                if (lastNanos &lt; 0) { lastNanos = now; return; }&#10;                double dt = (now - lastNanos) / 1e9;&#10;                lastNanos = now;&#10;&#10;                acc += dt;&#10;                double renderDt = 1.0 / 60.0;&#10;                while (acc &gt;= renderDt) {&#10;                    world.update(renderDt);&#10;                    acc -= renderDt;&#10;                }&#10;                syncNodes();&#10;                updateHud(dt);&#10;            }&#10;        };&#10;        timer.start();&#10;    }&#10;&#10;&#10;    private void updateCameraTransform() {&#10;        Group g = new Group();&#10;        g.getTransforms().setAll(camRY, camRX);&#10;        cam.getTransforms().setAll(g.getTransforms());&#10;        cam.setTranslateX(camTX);&#10;        cam.setTranslateY(camTY);&#10;        cam.setTranslateZ(-camDist);&#10;    }&#10;&#10;    // ===== Mundo de física demo =====&#10;    private void setupWorld() {&#10;        world = new World();&#10;&#10;        phys.collision.Collision.setPositionCorrection(0.95, 5e-4);&#10;        phys.collision.Collision.setNormalImpulseVSlop(2e-3);&#10;        phys.collision.Collision.setWakeThresholds(1e-3, 1e-3);&#10;&#10;        world.setFixedTimeStep(1.0 / 120.0);&#10;        world.setSubsteps(4);&#10;        world.setSolverIterations(8);&#10;        world.setSleepVelThreshold(0.03);&#10;        world.setSleepTime(0.4);&#10;&#10;        var ground = World.staticPlane(new Vec3(0, 1, 0), 0.0);&#10;        ground.setFrictionStatic(0.6);&#10;        ground.setFrictionDynamic(0.5);&#10;&#10;        var ball = World.dynamicSphere(new Vec3(-0.8, 2.0, 0.0), 0.25, 1.0);&#10;        ball.setRestitution(0.4);&#10;        ball.setFrictionStatic(0.4);&#10;        ball.setFrictionDynamic(0.3);&#10;&#10;        var box = World.dynamicBox(new Vec3(0.8, 1.6, 0.0), new Vec3(0.2, 0.2, 0.2), 2.0);&#10;        box.setRestitution(0.2);&#10;        box.setFrictionStatic(0.6);&#10;        box.setFrictionDynamic(0.5);&#10;&#10;        world.addBody(ground);&#10;        world.addBody(ball);&#10;        world.addBody(box);&#10;    }&#10;&#10;    private void resetWorld() {&#10;        nodes.clear();&#10;        worldGroup.getChildren().clear();&#10;        setupWorld();&#10;        buildSceneNodes();&#10;        gridNode = makeGroundChecker(20, 20, 0.5);&#10;        worldGroup.getChildren().add(gridNode);&#10;        worldGroup.getChildren().add(makeAxes(2.0));&#10;        var key = new PointLight(Color.WHITE);&#10;        key.setTranslateX(600);&#10;        key.setTranslateY(-800);&#10;        key.setTranslateZ(-600);&#10;        worldGroup.getChildren().addAll(key, new AmbientLight(Color.color(0.35, 0.35, 0.4)));&#10;    }&#10;&#10;    private void giveSpherePush() {&#10;        for (RigidBody b : world.bodies()) {&#10;            if (b.shape() instanceof phys.collision.Sphere) {&#10;                b.wakeUp();&#10;                b.setVelocity(b.velocity().add(new Vec3(3.0, 0, 0)));&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void toggleGridVisibility() {&#10;        if (gridNode != null) {&#10;            gridNode.setVisible(!gridNode.isVisible());&#10;            // atualiza HUD imediatamente com estado do grid&#10;            String status = gridNode.isVisible() ? &quot;ON&quot; : &quot;OFF&quot;;&#10;            hud.setText(helpText(String.format(&quot;FPS: --.- | Grid: %s&quot;, status)));&#10;        }&#10;    }&#10;&#10;    // ===== Nodes 3D =====&#10;    private void buildSceneNodes() {&#10;        for (RigidBody b : world.bodies()) {&#10;            Node node = createNodeFor(b);&#10;            if (node != null) {&#10;                nodes.put(b, node);&#10;                worldGroup.getChildren().add(node);&#10;            }&#10;        }&#10;    }&#10;&#10;    private Node createNodeFor(RigidBody b) {&#10;        if (b.shape() instanceof Plane p) {&#10;            // slab visual clicável sobre y=0&#10;            Box mesh = new Box(50*M2PX, 2, 50*M2PX);&#10;            mesh.setTranslateY((0 - p.d) * M2PX + 1);&#10;            mesh.setMaterial(mat(Color.web(&quot;#1b1f2a&quot;)));&#10;            // mesh.setMouseTransparent(false); // padrão já é clicável&#10;            return mesh;&#10;        } else if (b.shape() instanceof phys.collision.Sphere s) {&#10;            double r = s.radius * M2PX;&#10;            Sphere mesh = new Sphere(r, 48);&#10;            mesh.setMaterial(mat(Color.web(&quot;#3fa7ff&quot;)));&#10;            return mesh;&#10;        } else if (b.shape() instanceof phys.collision.AABB aabb) {&#10;            Vec3 he = aabb.halfExtents; // se for getter: aabb.getHalfExtents()&#10;            Box mesh = new Box(2*he.x()*M2PX, 2*he.y()*M2PX, 2*he.z()*M2PX);&#10;            mesh.setMaterial(mat(Color.web(&quot;#ff8f3f&quot;)));&#10;            return mesh;&#10;        }&#10;        return null;&#10;    }&#10;&#10;&#10;    private void syncNodes() {&#10;        for (var e : nodes.entrySet()) {&#10;            RigidBody b = e.getKey();&#10;            Node n = e.getValue();&#10;&#10;            if (!(b.shape() instanceof Plane)) {&#10;                var p = b.position();&#10;                n.setTranslateX(p.x() * M2PX);&#10;                n.setTranslateY((0 - p.y()) * M2PX);&#10;                n.setTranslateZ(p.z() * M2PX);&#10;            }&#10;            if (n instanceof Shape3D s) {&#10;                PhongMaterial m = (PhongMaterial) s.getMaterial();&#10;                if (b.isSleeping()) {&#10;                    m.setDiffuseColor(m.getDiffuseColor().darker().darker());&#10;                } else {&#10;                    m.setDiffuseColor(m.getDiffuseColor().brighter());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // ===== Helpers visuais =====&#10;    private PhongMaterial mat(Color c) {&#10;        PhongMaterial m = new PhongMaterial(c);&#10;        m.setSpecularColor(c.interpolate(Color.WHITE, 0.35));&#10;        return m;&#10;    }&#10;&#10;    /**&#10;     * Eixos XYZ (X=vermelho, Y=verde, Z=azul) com 2m de comprimento por padrão.&#10;     */&#10;    private Group makeAxes(double lengthMeters) {&#10;        double L = lengthMeters * M2PX;&#10;        double R = 2.5;&#10;&#10;        Cylinder x = new Cylinder(R, L);&#10;        x.setMaterial(mat(Color.RED));&#10;        x.setRotationAxis(Rotate.Z_AXIS);&#10;        x.setRotate(90);&#10;        x.setTranslateX(L / 2);&#10;&#10;        Cylinder y = new Cylinder(R, L);&#10;        y.setMaterial(mat(Color.LIMEGREEN));&#10;        y.setTranslateY(-L / 2);&#10;&#10;        Cylinder z = new Cylinder(R, L);&#10;        z.setMaterial(mat(Color.CORNFLOWERBLUE));&#10;        z.setRotationAxis(Rotate.X_AXIS);&#10;        z.setRotate(90);&#10;        z.setTranslateZ(L / 2);&#10;&#10;        Group g = new Group(x, y, z);&#10;        g.setMouseTransparent(true);&#10;        return g;&#10;    }&#10;&#10;    private Group makeGroundChecker(int nx, int nz, double cellMeters) {&#10;        double s = cellMeters * M2PX;&#10;        Group g = new Group();&#10;        for (int ix = -nx; ix &lt; nx; ix++) {&#10;            for (int iz = -nz; iz &lt; nz; iz++) {&#10;                Box quad = new Box(s, 1, s);&#10;                quad.setTranslateX(ix * s + s/2.0);&#10;                quad.setTranslateY(1);&#10;                quad.setTranslateZ(iz * s + s/2.0);&#10;                boolean even = ((ix + iz) &amp; 1) == 0;&#10;                Color c = even ? Color.web(&quot;#141922&quot;) : Color.web(&quot;#10141b&quot;);&#10;                quad.setMaterial(mat(c));&#10;                g.getChildren().add(quad);&#10;            }&#10;        }&#10;        return g;&#10;    }&#10;&#10;&#10;    // ===== HUD/FPS =====&#10;    private void updateHud(double dt) {&#10;        fpsTime += dt;&#10;        fpsFrames++;&#10;        if (fpsTime &gt;= 0.5) {&#10;            double fps = fpsFrames / fpsTime;&#10;            fpsFrames = 0;&#10;            fpsTime = 0;&#10;            String gridState = (gridNode != null &amp;&amp; gridNode.isVisible()) ? &quot;ON&quot; : &quot;OFF&quot;;&#10;            hud.setText(helpText(String.format(&quot;FPS: %.1f | Grid: %s&quot;, fps, gridState)));&#10;        }&#10;    }&#10;&#10;    private String helpText(String extra) {&#10;        return &quot;&quot;&quot;&#10;                   Physics 3D Viewer&#10;                   Mouse: arrastar = orbitar | Shift+arrastar = pan | Scroll = zoom&#10;                   Teclas: R = reset | Espaço = empurrar esfera | G = toggle grid&#10;                   &quot;&quot;&quot; + extra;&#10;    }&#10;&#10;    private static double clamp(double v, double lo, double hi) {&#10;        return Math.max(lo, Math.min(hi, v));&#10;    }&#10;&#10;    /**&#10;     * Cria uma esfera e arremessa na direção do ponto clicado (botão direito).&#10;     * Usa o PickResult do MouseEvent; se não houver interseção, mira &quot;para frente&quot; da câmera.&#10;     */&#10;    private void throwSphereFromClick(MouseEvent e) {&#10;        // origem do raio = posição da câmera em coords de cena&#10;        Point3D camScene = cam.localToScene(0, 0, 0);&#10;        Vec3 originPhys = new Vec3(camScene.getX()/M2PX, -camScene.getY()/M2PX, camScene.getZ()/M2PX);&#10;&#10;        // direção&#10;        Vec3 dirPhys;&#10;        PickResult pr = e.getPickResult();&#10;        if (pr != null &amp;&amp; pr.getIntersectedPoint() != null) {&#10;            Point3D hit = pr.getIntersectedPoint();&#10;            Vec3 hitPhys = new Vec3(hit.getX()/M2PX, -hit.getY()/M2PX, hit.getZ()/M2PX);&#10;            dirPhys = hitPhys.sub(originPhys).normalized();&#10;        } else {&#10;            // fallback: vetor &quot;para frente&quot; da câmera&#10;            Point3D forwardScene = cam.localToScene(0, 0, -1);&#10;            dirPhys = new Vec3(&#10;                (forwardScene.getX() - camScene.getX()),&#10;                -(forwardScene.getY() - camScene.getY()),&#10;                (forwardScene.getZ() - camScene.getZ())&#10;            ).normalized();&#10;        }&#10;&#10;        // spawn 30 cm à frente da câmera&#10;        Vec3 spawn = originPhys.add(dirPhys.mul(0.30));&#10;&#10;        // cria corpo físico&#10;        var body = World.dynamicSphere(spawn, THROW_RADIUS, THROW_MASS);&#10;        body.setRestitution(0.3);&#10;        body.setFrictionStatic(0.4);&#10;        body.setFrictionDynamic(0.3);&#10;        body.setVelocity(dirPhys.mul(THROW_SPEED));&#10;&#10;        // registra no mundo e cria o node visual&#10;        addBodyAndNode(body);&#10;    }&#10;&#10;&#10;    /** Adiciona o corpo no mundo e cria o Node JavaFX correspondente. */&#10;    private void addBodyAndNode(RigidBody b) {&#10;        world.addBody(b);&#10;        Node node = createNodeFor(b);&#10;        if (node != null) {&#10;            nodes.put(b, node);&#10;            worldGroup.getChildren().add(node);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        launch(args);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package phys.view;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import javafx.animation.AnimationTimer;&#10;import javafx.application.Application;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Point3D;&#10;import javafx.scene.*;&#10;import javafx.scene.control.Label;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.input.PickResult;&#10;import javafx.scene.layout.StackPane;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.paint.PhongMaterial;&#10;import javafx.scene.shape.Box;&#10;import javafx.scene.shape.Cylinder;&#10;import javafx.scene.shape.Shape3D;&#10;import javafx.scene.shape.Sphere;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.transform.Rotate;&#10;import javafx.stage.Stage;&#10;import phys.collision.AABB;&#10;import phys.collision.Plane;&#10;import phys.core.RigidBody;&#10;import phys.core.World;&#10;import phys.math.Vec3;&#10;&#10;/**&#10; * Viewer 3D para inspecionar a simulação física.&#10; * &lt;p&gt;&#10; * Funcionalidades:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Câmera orbital (LMB arrasta), zoom (scroll), pan (Shift + arrastar)&lt;/li&gt;&#10; *   &lt;li&gt;Grid xadrez no chão e eixos XYZ&lt;/li&gt;&#10; *   &lt;li&gt;HUD com FPS/ajuda&lt;/li&gt;&#10; *   &lt;li&gt;Cor dos corpos muda quando entram em sleep&lt;/li&gt;&#10; *   &lt;li&gt;Teclas: R reset | Espaço empurra esfera | G mostra/esconde grid&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; */&#10;public class PhysViewerApp extends Application {&#10;&#10;    /** Escala de conversão: 1 metro = 100 pixels. */&#10;    private static final double M2PX = 100.0;&#10;&#10;    /** Mapeamento entre corpos físicos e seus nós visuais. */&#10;    private final Map&lt;RigidBody, Node&gt; nodes = new HashMap&lt;&gt;();&#10;    /** Mundo físico da simulação. */&#10;    private World world;&#10;    /** Grupo raiz dos objetos 3D. */&#10;    private Group worldGroup;&#10;    /** Câmera principal da cena. */&#10;    private PerspectiveCamera cam;&#10;&#10;    // câmera orbital&#10;    /** Rotação X da câmera orbital. */&#10;    private final Rotate camRX = new Rotate(-30, Rotate.X_AXIS);&#10;    /** Rotação Y da câmera orbital. */&#10;    private final Rotate camRY = new Rotate(35, Rotate.Y_AXIS);&#10;    /** Distância da câmera ao centro da cena (em px). */&#10;    private double camDist = 900;&#10;    /** Pan da câmera em X. */&#10;    private double camTX = 0;&#10;    /** Pan da câmera em Y. */&#10;    private double camTY = 80;&#10;    /** Última posição X do mouse. */&#10;    private double lastX, lastY;&#10;    /** Indica se está em modo pan. */&#10;    private boolean panning = false;&#10;&#10;    /** Nó do grid do chão (para alternar visibilidade). */&#10;    private Node gridNode;&#10;&#10;    /** Label do HUD (FPS e ajuda). */&#10;    private Label hud;&#10;    /** Acumulador de tempo para cálculo de FPS. */&#10;    private double fpsTime = 0;&#10;    /** Contador de frames para cálculo de FPS. */&#10;    private int fpsFrames = 0;&#10;&#10;    /** SubScene 3D principal. */&#10;    private SubScene sub;&#10;    /** Velocidade inicial (m/s) da esfera arremessada. */&#10;    private static final double THROW_SPEED = 6.0;&#10;    /** Raio da esfera arremessada (m). */&#10;    private static final double THROW_RADIUS = 0.15;&#10;    /** Massa da esfera arremessada (kg). */&#10;    private static final double THROW_MASS = 0.5;&#10;&#10;    /**&#10;     * Inicializa a aplicação JavaFX, monta a cena, HUD e interações.&#10;     * @param stage Palco principal da aplicação.&#10;     */&#10;    @Override&#10;    public void start(Stage stage) {&#10;        setupWorld();&#10;&#10;        worldGroup = new Group();&#10;        buildSceneNodes();&#10;&#10;        // chão + grid + eixos&#10;        gridNode = makeGroundChecker(20, 20, 0.5); // 20x20 quadros de 0.5m&#10;        worldGroup.getChildren().add(gridNode);&#10;        worldGroup.getChildren().add(makeAxes(2.0)); // eixos de 2m&#10;&#10;        // luzes&#10;        var key = new PointLight(Color.WHITE);&#10;        key.setTranslateX(600);&#10;        key.setTranslateY(-800);&#10;        key.setTranslateZ(-600);&#10;        var amb = new AmbientLight(Color.color(0.35, 0.35, 0.4));&#10;        worldGroup.getChildren().addAll(key, amb);&#10;&#10;        // SubScene 3D&#10;        sub = new SubScene(worldGroup, 1280, 720, true, SceneAntialiasing.BALANCED);&#10;        sub.setFill(Color.web(&quot;#0c0f14&quot;));&#10;&#10;        cam = new PerspectiveCamera(true);&#10;        cam.setFieldOfView(45);&#10;        cam.setNearClip(0.05);&#10;        cam.setFarClip(20000);&#10;        sub.setCamera(cam);&#10;        updateCameraTransform();&#10;&#10;        // HUD&#10;        hud = new Label(helpText(&quot;FPS: --.- | Grid: ON&quot;));&#10;        hud.setTextFill(Color.web(&quot;#e6eef7&quot;));&#10;        hud.setFont(Font.font(&quot;Consolas&quot;, 14));&#10;        hud.setPadding(new Insets(8));&#10;        StackPane root = new StackPane(sub, hud);&#10;        StackPane.setAlignment(hud, javafx.geometry.Pos.TOP_LEFT);&#10;&#10;        Scene scene = new Scene(root);&#10;        stage.setTitle(&quot;Physics 3D Viewer&quot;);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;&#10;        // ===== Interações =====&#10;        sub.setOnScroll(e -&gt; { camDist = clamp(camDist - e.getDeltaY(), 120, 4000); updateCameraTransform(); });&#10;        sub.setOnMousePressed(e -&gt; { lastX = e.getSceneX(); lastY = e.getSceneY(); panning = e.isShiftDown(); });&#10;        sub.setOnMouseDragged(e -&gt; {&#10;            double dx = e.getSceneX() - lastX, dy = e.getSceneY() - lastY;&#10;            lastX = e.getSceneX(); lastY = e.getSceneY();&#10;            if (panning) {&#10;                camTX += dx * (camDist / 800.0);&#10;                camTY += dy * (camDist / 800.0);&#10;            } else {&#10;                camRY.setAngle(camRY.getAngle() - dx * 0.25);&#10;                camRX.setAngle(clamp(camRX.getAngle() + dy * 0.25, -85, 85));&#10;            }&#10;            updateCameraTransform();&#10;        });&#10;&#10;        scene.setOnKeyPressed(e -&gt; {&#10;            switch (e.getCode()) {&#10;                case R -&gt; resetWorld();&#10;                case SPACE -&gt; giveSpherePush();&#10;                case G -&gt; toggleGridVisibility();&#10;            }&#10;        });&#10;&#10;        // **Clique direito**: arremessar esfera para o ponto clicado&#10;        sub.setOnMouseClicked(e -&gt; {&#10;            if (e.getButton() == javafx.scene.input.MouseButton.SECONDARY) {&#10;                throwSphereFromClick(e); // usa e.getPickResult()&#10;            }&#10;        });&#10;&#10;        // loop 60Hz&#10;        AnimationTimer timer = new AnimationTimer() {&#10;            long lastNanos = -1;&#10;            double acc = 0.0;&#10;            @Override&#10;            public void handle(long now) {&#10;                if (lastNanos &lt; 0) { lastNanos = now; return; }&#10;                double dt = (now - lastNanos) / 1e9;&#10;                lastNanos = now;&#10;&#10;                acc += dt;&#10;                double renderDt = 1.0 / 60.0;&#10;                while (acc &gt;= renderDt) {&#10;                    world.update(renderDt);&#10;                    acc -= renderDt;&#10;                }&#10;                syncNodes();&#10;                updateHud(dt);&#10;            }&#10;        };&#10;        timer.start();&#10;    }&#10;&#10;    /**&#10;     * Atualiza a transformação da câmera orbital (posição, rotação, pan, zoom).&#10;     */&#10;    private void updateCameraTransform() {&#10;        Group g = new Group();&#10;        g.getTransforms().setAll(camRY, camRX);&#10;        cam.getTransforms().setAll(g.getTransforms());&#10;        cam.setTranslateX(camTX);&#10;        cam.setTranslateY(camTY);&#10;        cam.setTranslateZ(-camDist);&#10;    }&#10;&#10;    // ===== Mundo de física demo =====&#10;    /**&#10;     * Cria e configura o mundo físico de demonstração (chão, esfera, caixa).&#10;     */&#10;    private void setupWorld() {&#10;        world = new World();&#10;&#10;        phys.collision.Collision.setPositionCorrection(0.95, 5e-4);&#10;        phys.collision.Collision.setNormalImpulseVSlop(2e-3);&#10;        phys.collision.Collision.setWakeThresholds(1e-3, 1e-3);&#10;&#10;        world.setFixedTimeStep(1.0 / 120.0);&#10;        world.setSubsteps(4);&#10;        world.setSolverIterations(8);&#10;        world.setSleepVelThreshold(0.03);&#10;        world.setSleepTime(0.4);&#10;&#10;        var ground = World.staticPlane(new Vec3(0, 1, 0), 0.0);&#10;        ground.setFrictionStatic(0.6);&#10;        ground.setFrictionDynamic(0.5);&#10;&#10;        var ball = World.dynamicSphere(new Vec3(-0.8, 2.0, 0.0), 0.25, 1.0);&#10;        ball.setRestitution(0.4);&#10;        ball.setFrictionStatic(0.4);&#10;        ball.setFrictionDynamic(0.3);&#10;&#10;        var box = World.dynamicBox(new Vec3(0.8, 1.6, 0.0), new Vec3(0.2, 0.2, 0.2), 2.0);&#10;        box.setRestitution(0.2);&#10;        box.setFrictionStatic(0.6);&#10;        box.setFrictionDynamic(0.5);&#10;&#10;        world.addBody(ground);&#10;        world.addBody(ball);&#10;        world.addBody(box);&#10;    }&#10;&#10;    /**&#10;     * Reinicia o mundo físico e a cena visual.&#10;     */&#10;    private void resetWorld() {&#10;        nodes.clear();&#10;        worldGroup.getChildren().clear();&#10;        setupWorld();&#10;        buildSceneNodes();&#10;        gridNode = makeGroundChecker(20, 20, 0.5);&#10;        worldGroup.getChildren().add(gridNode);&#10;        worldGroup.getChildren().add(makeAxes(2.0));&#10;        var key = new PointLight(Color.WHITE);&#10;        key.setTranslateX(600);&#10;        key.setTranslateY(-800);&#10;        key.setTranslateZ(-600);&#10;        worldGroup.getChildren().addAll(key, new AmbientLight(Color.color(0.35, 0.35, 0.4)));&#10;    }&#10;&#10;    /**&#10;     * Aplica um impulso à primeira esfera encontrada no mundo.&#10;     */&#10;    private void giveSpherePush() {&#10;        for (RigidBody b : world.bodies()) {&#10;            if (b.shape() instanceof phys.collision.Sphere) {&#10;                b.wakeUp();&#10;                b.setVelocity(b.velocity().add(new Vec3(3.0, 0, 0)));&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Alterna a visibilidade do grid do chão e atualiza o HUD.&#10;     */&#10;    private void toggleGridVisibility() {&#10;        if (gridNode != null) {&#10;            gridNode.setVisible(!gridNode.isVisible());&#10;            // atualiza HUD imediatamente com estado do grid&#10;            String status = gridNode.isVisible() ? &quot;ON&quot; : &quot;OFF&quot;;&#10;            hud.setText(helpText(String.format(&quot;FPS: --.- | Grid: %s&quot;, status)));&#10;        }&#10;    }&#10;&#10;    // ===== Nodes 3D =====&#10;    /**&#10;     * Cria os nós visuais para todos os corpos do mundo físico.&#10;     */&#10;    private void buildSceneNodes() {&#10;        for (RigidBody b : world.bodies()) {&#10;            Node node = createNodeFor(b);&#10;            if (node != null) {&#10;                nodes.put(b, node);&#10;                worldGroup.getChildren().add(node);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cria o Node JavaFX correspondente ao corpo físico informado.&#10;     * @param b Corpo físico&#10;     * @return Node visual ou null se não suportado&#10;     */&#10;    private Node createNodeFor(RigidBody b) {&#10;        if (b.shape() instanceof Plane p) {&#10;            // slab visual clicável sobre y=0&#10;            Box mesh = new Box(50*M2PX, 2, 50*M2PX);&#10;            mesh.setTranslateY((0 - p.d) * M2PX + 1);&#10;            mesh.setMaterial(mat(Color.web(&quot;#1b1f2a&quot;)));&#10;            // mesh.setMouseTransparent(false); // padrão já é clicável&#10;            return mesh;&#10;        } else if (b.shape() instanceof phys.collision.Sphere s) {&#10;            double r = s.radius * M2PX;&#10;            Sphere mesh = new Sphere(r, 48);&#10;            mesh.setMaterial(mat(Color.web(&quot;#3fa7ff&quot;)));&#10;            return mesh;&#10;        } else if (b.shape() instanceof phys.collision.AABB aabb) {&#10;            Vec3 he = aabb.halfExtents; // se for getter: aabb.getHalfExtents()&#10;            Box mesh = new Box(2*he.x()*M2PX, 2*he.y()*M2PX, 2*he.z()*M2PX);&#10;            mesh.setMaterial(mat(Color.web(&quot;#ff8f3f&quot;)));&#10;            return mesh;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Sincroniza a posição e cor dos nós visuais com o estado dos corpos físicos.&#10;     */&#10;    private void syncNodes() {&#10;        for (var e : nodes.entrySet()) {&#10;            RigidBody b = e.getKey();&#10;            Node n = e.getValue();&#10;&#10;            if (!(b.shape() instanceof Plane)) {&#10;                var p = b.position();&#10;                n.setTranslateX(p.x() * M2PX);&#10;                n.setTranslateY((0 - p.y()) * M2PX);&#10;                n.setTranslateZ(p.z() * M2PX);&#10;            }&#10;            if (n instanceof Shape3D s) {&#10;                PhongMaterial m = (PhongMaterial) s.getMaterial();&#10;                if (b.isSleeping()) {&#10;                    m.setDiffuseColor(m.getDiffuseColor().darker().darker());&#10;                } else {&#10;                    m.setDiffuseColor(m.getDiffuseColor().brighter());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // ===== Helpers visuais =====&#10;    /**&#10;     * Cria um material Phong com cor base e especular.&#10;     * @param c Cor base&#10;     * @return Material Phong&#10;     */&#10;    private PhongMaterial mat(Color c) {&#10;        PhongMaterial m = new PhongMaterial(c);&#10;        m.setSpecularColor(c.interpolate(Color.WHITE, 0.35));&#10;        return m;&#10;    }&#10;&#10;    /**&#10;     * Cria eixos XYZ (X=vermelho, Y=verde, Z=azul) com comprimento especificado.&#10;     * @param lengthMeters Comprimento em metros&#10;     * @return Grupo com os eixos&#10;     */&#10;    private Group makeAxes(double lengthMeters) {&#10;        double L = lengthMeters * M2PX;&#10;        double R = 2.5;&#10;&#10;        Cylinder x = new Cylinder(R, L);&#10;        x.setMaterial(mat(Color.RED));&#10;        x.setRotationAxis(Rotate.Z_AXIS);&#10;        x.setRotate(90);&#10;        x.setTranslateX(L / 2);&#10;&#10;        Cylinder y = new Cylinder(R, L);&#10;        y.setMaterial(mat(Color.LIMEGREEN));&#10;        y.setTranslateY(-L / 2);&#10;&#10;        Cylinder z = new Cylinder(R, L);&#10;        z.setMaterial(mat(Color.CORNFLOWERBLUE));&#10;        z.setRotationAxis(Rotate.X_AXIS);&#10;        z.setRotate(90);&#10;        z.setTranslateZ(L / 2);&#10;&#10;        Group g = new Group(x, y, z);&#10;        g.setMouseTransparent(true);&#10;        return g;&#10;    }&#10;&#10;    /**&#10;     * Cria um grid xadrez no chão.&#10;     * @param nx Número de quadros em X&#10;     * @param nz Número de quadros em Z&#10;     * @param cellMeters Tamanho de cada quadro (m)&#10;     * @return Grupo com o grid&#10;     */&#10;    private Group makeGroundChecker(int nx, int nz, double cellMeters) {&#10;        double s = cellMeters * M2PX;&#10;        Group g = new Group();&#10;        for (int ix = -nx; ix &lt; nx; ix++) {&#10;            for (int iz = -nz; iz &lt; nz; iz++) {&#10;                Box quad = new Box(s, 1, s);&#10;                quad.setTranslateX(ix * s + s/2.0);&#10;                quad.setTranslateY(1);&#10;                quad.setTranslateZ(iz * s + s/2.0);&#10;                boolean even = ((ix + iz) &amp; 1) == 0;&#10;                Color c = even ? Color.web(&quot;#141922&quot;) : Color.web(&quot;#10141b&quot;);&#10;                quad.setMaterial(mat(c));&#10;                g.getChildren().add(quad);&#10;            }&#10;        }&#10;        return g;&#10;    }&#10;&#10;&#10;    // ===== HUD/FPS =====&#10;    /**&#10;     * Atualiza o HUD com FPS e estado do grid.&#10;     * @param dt Delta de tempo desde o último frame&#10;     */&#10;    private void updateHud(double dt) {&#10;        fpsTime += dt;&#10;        fpsFrames++;&#10;        if (fpsTime &gt;= 0.5) {&#10;            double fps = fpsFrames / fpsTime;&#10;            fpsFrames = 0;&#10;            fpsTime = 0;&#10;            String gridState = (gridNode != null &amp;&amp; gridNode.isVisible()) ? &quot;ON&quot; : &quot;OFF&quot;;&#10;            hud.setText(helpText(String.format(&quot;FPS: %.1f | Grid: %s&quot;, fps, gridState)));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retorna o texto de ajuda do HUD, incluindo informações extras.&#10;     * @param extra Texto adicional&#10;     * @return Texto formatado&#10;     */&#10;    private String helpText(String extra) {&#10;        return &quot;&quot;&quot;&#10;                   Physics 3D Viewer&#10;                   Mouse: arrastar = orbitar | Shift+arrastar = pan | Scroll = zoom&#10;                   Teclas: R = reset | Espaço = empurrar esfera | G = toggle grid&#10;                   &quot;&quot;&quot; + extra;&#10;    }&#10;&#10;    /**&#10;     * Limita um valor entre mínimo e máximo.&#10;     * @param v Valor&#10;     * @param lo Mínimo&#10;     * @param hi Máximo&#10;     * @return Valor limitado&#10;     */&#10;    private static double clamp(double v, double lo, double hi) {&#10;        return Math.max(lo, Math.min(hi, v));&#10;    }&#10;&#10;    /**&#10;     * Cria uma esfera e arremessa na direção do ponto clicado (botão direito).&#10;     * Usa o PickResult do MouseEvent; se não houver interseção, mira &quot;para frente&quot; da câmera.&#10;     * @param e Evento de mouse&#10;     */&#10;    private void throwSphereFromClick(MouseEvent e) {&#10;        // origem do raio = posição da câmera em coords de cena&#10;        Point3D camScene = cam.localToScene(0, 0, 0);&#10;        Vec3 originPhys = new Vec3(camScene.getX()/M2PX, -camScene.getY()/M2PX, camScene.getZ()/M2PX);&#10;&#10;        // direção&#10;        Vec3 dirPhys;&#10;        PickResult pr = e.getPickResult();&#10;        if (pr != null &amp;&amp; pr.getIntersectedPoint() != null) {&#10;            Point3D hit = pr.getIntersectedPoint();&#10;            Vec3 hitPhys = new Vec3(hit.getX()/M2PX, -hit.getY()/M2PX, hit.getZ()/M2PX);&#10;            dirPhys = hitPhys.sub(originPhys).normalized();&#10;        } else {&#10;            // fallback: vetor &quot;para frente&quot; da câmera&#10;            Point3D forwardScene = cam.localToScene(0, 0, -1);&#10;            dirPhys = new Vec3(&#10;                (forwardScene.getX() - camScene.getX()),&#10;                -(forwardScene.getY() - camScene.getY()),&#10;                (forwardScene.getZ() - camScene.getZ())&#10;            ).normalized();&#10;        }&#10;&#10;        // spawn 30 cm à frente da câmera&#10;        Vec3 spawn = originPhys.add(dirPhys.mul(0.30));&#10;&#10;        // cria corpo físico&#10;        var body = World.dynamicSphere(spawn, THROW_RADIUS, THROW_MASS);&#10;        body.setRestitution(0.3);&#10;        body.setFrictionStatic(0.4);&#10;        body.setFrictionDynamic(0.3);&#10;        body.setVelocity(dirPhys.mul(THROW_SPEED));&#10;&#10;        // registra no mundo e cria o node visual&#10;        addBodyAndNode(body);&#10;    }&#10;&#10;    /**&#10;     * Adiciona o corpo no mundo e cria o Node JavaFX correspondente.&#10;     * @param b Corpo físico&#10;     */&#10;    private void addBodyAndNode(RigidBody b) {&#10;        world.addBody(b);&#10;        Node node = createNodeFor(b);&#10;        if (node != null) {&#10;            nodes.put(b, node);&#10;            worldGroup.getChildren().add(node);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Método principal. Inicia a aplicação.&#10;     * @param args Argumentos de linha de comando&#10;     */&#10;    public static void main(String[] args) {&#10;        launch(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>