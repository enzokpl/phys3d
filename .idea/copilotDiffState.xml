<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Phys3D&#10;&#10;Phys3D é um motor de física 3D simples escrito em Java, com foco em aprendizado, experimentação e fácil integração em projetos Java. Ele implementa conceitos fundamentais de simulação física, como corpos rígidos, colisões, integração numérica e detecção de colisão por grade uniforme.&#10;&#10;## Funcionalidades&#10;- Simulação de corpos rígidos 3D&#10;- Detecção de colisão (AABB, Esfera, Plano)&#10;- Broadphase com grade uniforme&#10;- Integração semi-implícita de Euler&#10;- Suporte a múltiplos testes unitários e de performance&#10;- Visualizador simples (PhysViewerApp)&#10;&#10;## Estrutura do Projeto&#10;```&#10;src/&#10;  main/&#10;    java/phys/&#10;      broadphase/      # Algoritmos de broadphase&#10;      collision/       # Formas, colisões e AABB&#10;      core/            # Mundo e corpos rígidos&#10;      integration/     # Métodos de integração&#10;      math/            # Vetores e utilitários matemáticos&#10;      view/            # Visualizador&#10;  test/&#10;    java/phys/core/   # Testes unitários&#10;```&#10;&#10;## Como usar&#10;&#10;### Pré-requisitos&#10;- Java 8+&#10;- Maven&#10;&#10;### Compilação&#10;&#10;```bash&#10;mvn clean package&#10;```&#10;&#10;### Executando o visualizador&#10;&#10;```bash&#10;mvn exec:java -Dexec.mainClass=&quot;phys.view.PhysViewerApp&quot;&#10;```&#10;&#10;### Executando os testes&#10;&#10;```bash&#10;mvn test&#10;```&#10;&#10;## Exemplo de uso básico&#10;&#10;Veja o arquivo `PhysViewerApp.java` para um exemplo de como criar um mundo, adicionar corpos e rodar a simulação.&#10;&#10;## O que falta implementar&#10;- Suporte a mais tipos de formas (ex: caixa, cápsula, malha)&#10;- Resolução de colisão mais avançada (impulsos, fricção detalhada)&#10;- Otimizações de broadphase (ex: BVH, Sweep and Prune)&#10;- Suporte a constraints (juntas, molas)&#10;- Melhorias no visualizador (UI, interação)&#10;- Exportação/importação de cenas&#10;- Documentação detalhada da API&#10;&#10;## Contribuindo&#10;Pull requests são bem-vindos! Sinta-se à vontade para abrir issues ou sugerir melhorias.&#10;&#10;## Licença&#10;[MIT](LICENSE)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/phys/core/RigidBody.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/phys/core/RigidBody.java" />
              <option name="originalContent" value="package phys.core;&#10;&#10;import phys.collision.Shape;&#10;import phys.math.Vec3;&#10;&#10;/**&#10; * Representa um corpo rígido no mundo físico. Contém propriedades físicas como posição, velocidade, massa, forma,&#10; * coeficientes de restituição e atrito, e métodos para integração física e detecção de sono.&#10; */&#10;public final class RigidBody {&#10;    private Vec3 position;&#10;    private Vec3 velocity = Vec3.ZERO;&#10;    private Vec3 forceAccum = Vec3.ZERO;&#10;    private final double mass;&#10;    private final double invMass;&#10;    private final Shape shape;&#10;    private double restitution = 0.4; // “quique” básico&#10;    private double frictionStatic = 0.6;&#10;    private double frictionDynamic = 0.4;&#10;    private boolean canSleep = true;&#10;    private boolean sleeping = false;&#10;    private double sleepTimer = 0.0;&#10;&#10;    // Damping linear (s⁻¹). Ex.: 0.1 significa ~10%/s (dec decaimento exponencial).&#10;    private double linearDamping = 0.05;&#10;&#10;    // Filtro e histerese&#10;    private double velAvg = 0.0;         // EMA de |v|&#10;    private static final double EMA_ALPHA = 0.2; // suavização (0..1); maior = responde mais rápido&#10;&#10;    // Acúmulo de atividade no passo atual&#10;    private boolean hadContactThisStep = false;&#10;    private double maxImpulseThisStep = 0.0;     // Ns&#10;    private double maxCorrectionThisStep = 0.0;  // m&#10;&#10;    // Debug compacto&#10;    public static boolean DEBUG_SLEEP = false;&#10;    private static double DEBUG_ACC_TIME = 0.0; // acumulador para impressão espaçada&#10;&#10;    public RigidBody(Vec3 position, double mass, Shape shape) {&#10;        this.position = position;&#10;        this.mass = mass;&#10;        this.invMass = (mass &gt; 0) ? 1.0 / mass : 0.0; // 0 =&gt; estático&#10;        this.shape = shape;&#10;    }&#10;&#10;    public boolean isStatic() {&#10;        return invMass == 0.0;&#10;    }&#10;&#10;    public void addForce(Vec3 f) {&#10;        forceAccum = forceAccum.add(f);&#10;    }&#10;&#10;    public void clearForces() {&#10;        forceAccum = Vec3.ZERO;&#10;    }&#10;&#10;    public Vec3 position() {&#10;        return position;&#10;    }&#10;&#10;    public void setPosition(Vec3 p) {&#10;        position = p;&#10;    }&#10;&#10;    public Vec3 velocity() {&#10;        return velocity;&#10;    }&#10;&#10;    public void setVelocity(Vec3 v) {&#10;        velocity = v;&#10;    }&#10;&#10;    public double invMass() {&#10;        return invMass;&#10;    }&#10;&#10;    public Shape shape() {&#10;        return shape;&#10;    }&#10;&#10;    public double restitution() {&#10;        return restitution;&#10;    }&#10;&#10;    public void setRestitution(double r) {&#10;        restitution = Math.max(0, Math.min(1, r));&#10;    }&#10;    &#10;    /**&#10;     * Retorna o coeficiente de atrito estático.&#10;     */&#10;    public double frictionStatic() {&#10;        return frictionStatic;&#10;    }&#10;&#10;    /**&#10;     * Define o coeficiente de atrito estático (&gt;=0).&#10;     */&#10;    public void setFrictionStatic(double muS) {&#10;        this.frictionStatic = Math.max(0.0, muS);&#10;    }&#10;&#10;    /**&#10;     * Retorna o coeficiente de atrito dinâmico (cinético).&#10;     */&#10;    public double frictionDynamic() {&#10;        return frictionDynamic;&#10;    }&#10;&#10;    /**&#10;     * Define o coeficiente de atrito dinâmico (&gt;=0).&#10;     */&#10;    public void setFrictionDynamic(double muK) {&#10;        this.frictionDynamic = Math.max(0.0, muK);&#10;    }&#10;&#10;    /**&#10;     * Retorna o damping linear (s⁻¹).&#10;     */&#10;    public double linearDamping() {&#10;        return linearDamping;&#10;    }&#10;&#10;    /**&#10;     * Define o damping linear (s⁻¹). Valores pequenos (0.0–0.2) são razoáveis.&#10;     */&#10;    public void setLinearDamping(double damping) {&#10;        this.linearDamping = Math.max(0.0, damping);&#10;    }&#10;&#10;    public boolean canSleep() {&#10;        return canSleep;&#10;    }&#10;&#10;    /**&#10;     * Habilita/desabilita a capacidade de dormir. Se desabilitar, acorda o corpo.&#10;     */&#10;    public void setCanSleep(boolean canSleep) {&#10;        this.canSleep = canSleep;&#10;        if (!canSleep) {&#10;            this.sleeping = false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retorna se o corpo está dormindo (não é integrado nem colidido).&#10;     */&#10;    public boolean isSleeping() {&#10;        return sleeping;&#10;    }&#10;&#10;    /**&#10;     * Acorda imediatamente o corpo (volta a ser simulado normalmente).&#10;     */&#10;    public void wakeUp() {&#10;        this.sleeping = false;&#10;        this.sleepTimer = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Zera marcadores de atividade no início de cada step fixo.&#10;     */&#10;    public void beginStepActivityReset() {&#10;        hadContactThisStep = false;&#10;        maxImpulseThisStep = 0.0;&#10;        maxCorrectionThisStep = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Marca que houve contato neste step.&#10;     */&#10;    public void markContact() {&#10;        hadContactThisStep = true;&#10;    }&#10;&#10;    /**&#10;     * Acumula a maior magnitude de impulso visto neste step.&#10;     */&#10;    public void accumulateImpulse(double jMag) {&#10;        if (jMag &gt; maxImpulseThisStep) {&#10;            maxImpulseThisStep = jMag;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acumula a maior correção posicional vista neste step.&#10;     */&#10;    public void accumulateCorrection(double corrMag) {&#10;        if (corrMag &gt; maxCorrectionThisStep) {&#10;            maxCorrectionThisStep = corrMag;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Indica se houve contato neste step.&#10;     */&#10;    public boolean hadContactThisStep() {&#10;        return hadContactThisStep;&#10;    }&#10;&#10;    /**&#10;     * Maior impulso visto neste step (Ns).&#10;     */&#10;    public double maxImpulseThisStep() {&#10;        return maxImpulseThisStep;&#10;    }&#10;&#10;    /**&#10;     * Maior correção posicional vista neste step (m).&#10;     */&#10;    public double maxCorrectionThisStep() {&#10;        return maxCorrectionThisStep;&#10;    }&#10;&#10;    public double debugVelAvg() {&#10;        return velAvg;&#10;    }&#10;&#10;    public double debugSleepTimer() {&#10;        return sleepTimer;&#10;    }&#10;&#10;&#10;    /**&#10;     * Integra o corpo por um passo dt usando Semi-Implicit Euler. Aplica força acumulada + gravidade e um damping&#10;     * linear exponencial leve. Se o corpo estiver dormindo, apenas limpa forças.&#10;     */&#10;    public void integrate(Vec3 gravity, double dt) {&#10;        if (isStatic()) {&#10;            clearForces();&#10;            return;&#10;        }&#10;        if (sleeping) {&#10;            clearForces();&#10;            return;&#10;        }&#10;&#10;        Vec3 acc = forceAccum.mul(invMass).add(gravity);&#10;&#10;        // Semi-Implicit Euler&#10;        velocity = velocity.add(acc.mul(dt));&#10;&#10;        // Damping linear (decay exponencial estável)&#10;        double decay = Math.exp(-linearDamping * dt);&#10;        velocity = velocity.mul(decay);&#10;&#10;        position = position.add(velocity.mul(dt));&#10;        clearForces();&#10;    }&#10;&#10;    /**&#10;     * Atualiza o temporizador de sono baseado em |v| e EMA(|v|) com histerese. - Se velAvg ficar &lt; vThreshold por&#10;     * timeToSleep, entra em sleep. - Para acordar, exige |v| &gt; vThreshold * 1.5 (histerese). - Imprime debug compacto a&#10;     * cada ~0.1s quando DEBUG_SLEEP = true.&#10;     *&#10;     * @param dt passo de tempo&#10;     * @param vThresholdVel limiar de velocidade (m/s) para considerar &quot;parado&quot;&#10;     * @param timeToSleep tempo contínuo sob o limiar necessário para dormir (s)&#10;     */&#10;    /**&#10;     * Atualiza o temporizador de sono com base em: contato, |v| (EMA) e atividade (impulso/correção). Dorme quando: -&#10;     * houve contato (suporte) neste step, - velAvg &lt; vThresholdVel, - maxImpulseThisStep &lt;= impulseQuietThresh e&#10;     * maxCorrectionThisStep &lt;= correctionQuietThresh por tempo contínuo &gt;= timeToSleep.&#10;     */&#10;    public void accumulateSleepTimer(&#10;        double dt,&#10;        double vThresholdVel,&#10;        double timeToSleep,&#10;        double impulseQuietThresh,&#10;        double correctionQuietThresh&#10;    ) {&#10;        if (!canSleep || isStatic()) {&#10;            sleepTimer = 0.0;&#10;            sleeping = false;&#10;            velAvg = 0.0;&#10;            return;&#10;        }&#10;&#10;        double vLen = velocity.length();&#10;        if (velAvg == 0.0) {&#10;            velAvg = vLen;&#10;        }&#10;        velAvg = EMA_ALPHA * vLen + (1.0 - EMA_ALPHA) * velAvg;&#10;&#10;        boolean quietVelocity = velAvg &lt; vThresholdVel;&#10;        boolean quietContacts =&#10;            maxImpulseThisStep &lt;= impulseQuietThresh &amp;&amp; maxCorrectionThisStep &lt;= correctionQuietThresh;&#10;&#10;        if (hadContactThisStep &amp;&amp; quietVelocity &amp;&amp; quietContacts) {&#10;            sleepTimer += dt;&#10;            if (sleepTimer &gt;= timeToSleep) {&#10;                sleeping = true;&#10;                velocity = Vec3.ZERO;&#10;            }&#10;        } else {&#10;            sleepTimer = 0.0;&#10;            sleeping = false;&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package phys.core;&#10;&#10;import phys.collision.Shape;&#10;import phys.math.Vec3;&#10;&#10;/**&#10; * Representa um corpo rígido 3D para simulação física, com suporte a forças, atrito, repouso (sleep) e integração.&#10; * Permite configuração de massa, forma, coeficientes de restituição e atrito, além de gerenciamento de estado de sono.&#10; */&#10;public final class RigidBody {&#10;    private Vec3 position;&#10;    private Vec3 velocity = Vec3.ZERO;&#10;    private Vec3 forceAccum = Vec3.ZERO;&#10;    private final double mass;&#10;    private final double invMass;&#10;    private final Shape shape;&#10;    private double restitution = 0.4; // “quique” básico&#10;    private double frictionStatic = 0.6;&#10;    private double frictionDynamic = 0.4;&#10;    private boolean canSleep = true;&#10;    private boolean sleeping = false;&#10;    private double sleepTimer = 0.0;&#10;&#10;    // Damping linear (s⁻¹). Ex.: 0.1 significa ~10%/s (dec decaimento exponencial).&#10;    private double linearDamping = 0.05;&#10;&#10;    // Filtro e histerese&#10;    private double velAvg = 0.0;         // EMA de |v|&#10;    private static final double EMA_ALPHA = 0.2; // suavização (0..1); maior = responde mais rápido&#10;&#10;    // Acúmulo de atividade no passo atual&#10;    private boolean hadContactThisStep = false;&#10;    private double maxImpulseThisStep = 0.0;     // Ns&#10;    private double maxCorrectionThisStep = 0.0;  // m&#10;&#10;    // Debug compacto&#10;    public static boolean DEBUG_SLEEP = false;&#10;    private static double DEBUG_ACC_TIME = 0.0; // acumulador para impressão espaçada&#10;&#10;    /**&#10;     * Cria um novo corpo rígido.&#10;     *&#10;     * @param position Posição inicial do corpo.&#10;     * @param mass Massa do corpo (kg). Se for 0, o corpo é considerado estático.&#10;     * @param shape Forma geométrica usada para colisão.&#10;     */&#10;    public RigidBody(Vec3 position, double mass, Shape shape) {&#10;        this.position = position;&#10;        this.mass = mass;&#10;        this.invMass = (mass &gt; 0) ? 1.0 / mass : 0.0; // 0 =&gt; estático&#10;        this.shape = shape;&#10;    }&#10;&#10;    /**&#10;     * Indica se o corpo é estático (massa infinita).&#10;     *&#10;     * @return true se o corpo for estático, false caso contrário.&#10;     */&#10;    public boolean isStatic() {&#10;        return invMass == 0.0;&#10;    }&#10;&#10;    /**&#10;     * Adiciona uma força ao corpo (acumulada até o próximo passo de simulação).&#10;     *&#10;     * @param f Força a ser aplicada.&#10;     */&#10;    public void addForce(Vec3 f) {&#10;        forceAccum = forceAccum.add(f);&#10;    }&#10;&#10;    /**&#10;     * Limpa todas as forças acumuladas.&#10;     */&#10;    public void clearForces() {&#10;        forceAccum = Vec3.ZERO;&#10;    }&#10;&#10;    /**&#10;     * Retorna a posição atual do corpo.&#10;     *&#10;     * @return Posição (Vec3).&#10;     */&#10;    public Vec3 position() {&#10;        return position;&#10;    }&#10;&#10;    /**&#10;     * Define a posição do corpo.&#10;     *&#10;     * @param p Nova posição.&#10;     */&#10;    public void setPosition(Vec3 p) {&#10;        position = p;&#10;    }&#10;&#10;    /**&#10;     * Retorna a velocidade atual do corpo.&#10;     *&#10;     * @return Velocidade (Vec3).&#10;     */&#10;    public Vec3 velocity() {&#10;        return velocity;&#10;    }&#10;&#10;    /**&#10;     * Define a velocidade do corpo.&#10;     *&#10;     * @param v Nova velocidade.&#10;     */&#10;    public void setVelocity(Vec3 v) {&#10;        velocity = v;&#10;    }&#10;&#10;    /**&#10;     * Retorna o inverso da massa do corpo (0 para corpos estáticos).&#10;     *&#10;     * @return Inverso da massa.&#10;     */&#10;    public double invMass() {&#10;        return invMass;&#10;    }&#10;&#10;    /**&#10;     * Retorna a forma geométrica do corpo.&#10;     *&#10;     * @return Shape associado.&#10;     */&#10;    public Shape shape() {&#10;        return shape;&#10;    }&#10;&#10;    /**&#10;     * Retorna o coeficiente de restituição (elasticidade).&#10;     *&#10;     * @return Coeficiente de restituição (0 a 1).&#10;     */&#10;    public double restitution() {&#10;        return restitution;&#10;    }&#10;&#10;    /**&#10;     * Define o coeficiente de restituição (elasticidade).&#10;     *&#10;     * @param r Valor entre 0 e 1.&#10;     */&#10;    public void setRestitution(double r) {&#10;        restitution = Math.max(0, Math.min(1, r));&#10;    }&#10;&#10;    /**&#10;     * Retorna o coeficiente de atrito estático.&#10;     *&#10;     * @return Coeficiente de atrito estático.&#10;     */&#10;    public double frictionStatic() {&#10;        return frictionStatic;&#10;    }&#10;&#10;    /**&#10;     * Define o coeficiente de atrito estático (&gt;=0).&#10;     *&#10;     * @param muS Novo coeficiente de atrito estático.&#10;     */&#10;    public void setFrictionStatic(double muS) {&#10;        this.frictionStatic = Math.max(0.0, muS);&#10;    }&#10;&#10;    /**&#10;     * Retorna o coeficiente de atrito dinâmico (cinético).&#10;     *&#10;     * @return Coeficiente de atrito dinâmico.&#10;     */&#10;    public double frictionDynamic() {&#10;        return frictionDynamic;&#10;    }&#10;&#10;    /**&#10;     * Define o coeficiente de atrito dinâmico (&gt;=0).&#10;     *&#10;     * @param muK Novo coeficiente de atrito dinâmico.&#10;     */&#10;    public void setFrictionDynamic(double muK) {&#10;        this.frictionDynamic = Math.max(0.0, muK);&#10;    }&#10;&#10;    /**&#10;     * Retorna o damping linear (s⁻¹).&#10;     *&#10;     * @return Valor do damping linear.&#10;     */&#10;    public double linearDamping() {&#10;        return linearDamping;&#10;    }&#10;&#10;    /**&#10;     * Define o damping linear (s⁻¹). Valores pequenos (0.0–0.2) são razoáveis.&#10;     *&#10;     * @param damping Novo valor de damping linear.&#10;     */&#10;    public void setLinearDamping(double damping) {&#10;        this.linearDamping = Math.max(0.0, damping);&#10;    }&#10;&#10;    /**&#10;     * Indica se o corpo pode dormir (sleep).&#10;     *&#10;     * @return true se pode dormir, false caso contrário.&#10;     */&#10;    public boolean canSleep() {&#10;        return canSleep;&#10;    }&#10;&#10;    /**&#10;     * Habilita/desabilita a capacidade de dormir. Se desabilitar, acorda o corpo.&#10;     *&#10;     * @param canSleep true para permitir sleep, false para desabilitar.&#10;     */&#10;    public void setCanSleep(boolean canSleep) {&#10;        this.canSleep = canSleep;&#10;        if (!canSleep) {&#10;            this.sleeping = false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retorna se o corpo está dormindo (não é integrado nem colidido).&#10;     *&#10;     * @return true se está dormindo, false caso contrário.&#10;     */&#10;    public boolean isSleeping() {&#10;        return sleeping;&#10;    }&#10;&#10;    /**&#10;     * Acorda imediatamente o corpo (volta a ser simulado normalmente).&#10;     */&#10;    public void wakeUp() {&#10;        this.sleeping = false;&#10;        this.sleepTimer = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Zera marcadores de atividade no início de cada step fixo.&#10;     */&#10;    public void beginStepActivityReset() {&#10;        hadContactThisStep = false;&#10;        maxImpulseThisStep = 0.0;&#10;        maxCorrectionThisStep = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Marca que houve contato neste step.&#10;     */&#10;    public void markContact() {&#10;        hadContactThisStep = true;&#10;    }&#10;&#10;    /**&#10;     * Acumula a maior magnitude de impulso visto neste step.&#10;     *&#10;     * @param jMag Magnitude do impulso.&#10;     */&#10;    public void accumulateImpulse(double jMag) {&#10;        if (jMag &gt; maxImpulseThisStep) {&#10;            maxImpulseThisStep = jMag;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Acumula a maior correção posicional vista neste step.&#10;     *&#10;     * @param corrMag Magnitude da correção posicional.&#10;     */&#10;    public void accumulateCorrection(double corrMag) {&#10;        if (corrMag &gt; maxCorrectionThisStep) {&#10;            maxCorrectionThisStep = corrMag;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Indica se houve contato neste step.&#10;     *&#10;     * @return true se houve contato, false caso contrário.&#10;     */&#10;    public boolean hadContactThisStep() {&#10;        return hadContactThisStep;&#10;    }&#10;&#10;    /**&#10;     * Maior impulso visto neste step (Ns).&#10;     *&#10;     * @return Valor do maior impulso.&#10;     */&#10;    public double maxImpulseThisStep() {&#10;        return maxImpulseThisStep;&#10;    }&#10;&#10;    /**&#10;     * Maior correção posicional vista neste step (m).&#10;     *&#10;     * @return Valor da maior correção.&#10;     */&#10;    public double maxCorrectionThisStep() {&#10;        return maxCorrectionThisStep;&#10;    }&#10;&#10;    /**&#10;     * Valor médio exponencial da velocidade (para debug).&#10;     *&#10;     * @return Média exponencial de |v|.&#10;     */&#10;    public double debugVelAvg() {&#10;        return velAvg;&#10;    }&#10;&#10;    /**&#10;     * Temporizador de sono (para debug).&#10;     *&#10;     * @return Valor do temporizador de sono.&#10;     */&#10;    public double debugSleepTimer() {&#10;        return sleepTimer;&#10;    }&#10;&#10;    /**&#10;     * Integra o corpo por um passo dt usando Semi-Implicit Euler. Aplica força acumulada + gravidade e um damping&#10;     * linear exponencial leve. Se o corpo estiver dormindo, apenas limpa forças.&#10;     *&#10;     * @param gravity Vetor de gravidade a ser aplicado.&#10;     * @param dt Intervalo de tempo do passo (s).&#10;     */&#10;    public void integrate(Vec3 gravity, double dt) {&#10;        if (isStatic()) {&#10;            clearForces();&#10;            return;&#10;        }&#10;        if (sleeping) {&#10;            clearForces();&#10;            return;&#10;        }&#10;&#10;        Vec3 acc = forceAccum.mul(invMass).add(gravity);&#10;&#10;        // Semi-Implicit Euler&#10;        velocity = velocity.add(acc.mul(dt));&#10;&#10;        // Damping linear (decay exponencial estável)&#10;        double decay = Math.exp(-linearDamping * dt);&#10;        velocity = velocity.mul(decay);&#10;&#10;        position = position.add(velocity.mul(dt));&#10;        clearForces();&#10;    }&#10;&#10;    /**&#10;     * Atualiza o temporizador de sono com base em: contato, |v| (EMA) e atividade (impulso/correção). Dorme quando:&#10;     * - houve contato (suporte) neste step,&#10;     * - velAvg &lt; vThresholdVel,&#10;     * - maxImpulseThisStep &lt;= impulseQuietThresh e maxCorrectionThisStep &lt;= correctionQuietThresh por tempo contínuo &gt;= timeToSleep.&#10;     *&#10;     * @param dt Intervalo de tempo do passo (s).&#10;     * @param vThresholdVel Limiar de velocidade (m/s) para considerar &quot;parado&quot;.&#10;     * @param timeToSleep Tempo contínuo sob o limiar necessário para dormir (s).&#10;     * @param impulseQuietThresh Limiar de impulso para considerar &quot;quieto&quot;.&#10;     * @param correctionQuietThresh Limiar de correção posicional para considerar &quot;quieto&quot;.&#10;     */&#10;    public void accumulateSleepTimer(&#10;        double dt,&#10;        double vThresholdVel,&#10;        double timeToSleep,&#10;        double impulseQuietThresh,&#10;        double correctionQuietThresh&#10;    ) {&#10;        if (!canSleep || isStatic()) {&#10;            sleepTimer = 0.0;&#10;            sleeping = false;&#10;            velAvg = 0.0;&#10;            return;&#10;        }&#10;&#10;        double vLen = velocity.length();&#10;        if (velAvg == 0.0) {&#10;            velAvg = vLen;&#10;        }&#10;        velAvg = EMA_ALPHA * vLen + (1.0 - EMA_ALPHA) * velAvg;&#10;&#10;        boolean quietVelocity = velAvg &lt; vThresholdVel;&#10;        boolean quietContacts =&#10;            maxImpulseThisStep &lt;= impulseQuietThresh &amp;&amp; maxCorrectionThisStep &lt;= correctionQuietThresh;&#10;&#10;        if (hadContactThisStep &amp;&amp; quietVelocity &amp;&amp; quietContacts) {&#10;            sleepTimer += dt;&#10;            if (sleepTimer &gt;= timeToSleep) {&#10;                sleeping = true;&#10;                velocity = Vec3.ZERO;&#10;            }&#10;        } else {&#10;            sleepTimer = 0.0;&#10;            sleeping = false;&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/phys/core/World.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/phys/core/World.java" />
              <option name="originalContent" value="package phys.core;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import phys.broadphase.Broadphase;&#10;import AABB;&#10;import Collision;&#10;import Plane;&#10;import Sphere;&#10;import phys.math.Vec3;&#10;&#10;public final class World {&#10;    private final List&lt;RigidBody&gt; bodies = new ArrayList&lt;&gt;();&#10;    private Vec3 gravity = new Vec3(0, -9.81, 0);&#10;&#10;    // Novo controle de timestep fixo&#10;    private double fixedTimeStep = 1.0 / 120.0; // 120 Hz&#10;    private double accumulator = 0.0;&#10;    private int substeps = 1;&#10;    private int solverIterations = 4;&#10;    private Broadphase broadphase = null;&#10;    // --- Parâmetros globais de sleep ---&#10;    private double sleepVelThreshold = 0.05; // m/s&#10;    private double sleepTime = 0.5;          // s sob o limiar para dormir&#10;    // ==== DEBUG flags/estado (adicione no topo da classe World) ====&#10;    // Ligue/desligue logs compactos por step:&#10;    public static boolean DEBUG_SLEEP_LOGS = false;&#10;    private double debugLogAccum = 0.0;&#10;&#10;    /**&#10;     * Define o limiar de velocidade linear abaixo do qual o corpo é considerado &quot;parado&quot;.&#10;     */&#10;    public void setSleepVelThreshold(double v) {&#10;        this.sleepVelThreshold = Math.max(0.0, v);&#10;    }&#10;&#10;    /**&#10;     * Define o tempo contínuo necessário (s) sob o limiar para entrar em sleep.&#10;     */&#10;    public void setSleepTime(double seconds) {&#10;        this.sleepTime = Math.max(0.0, seconds);&#10;    }&#10;&#10;    public void setGravity(Vec3 g) {&#10;        this.gravity = g;&#10;        Collision.setGravity(g);&#10;    }&#10;&#10;    public Vec3 gravity() {&#10;        return gravity;&#10;    }&#10;&#10;    public List&lt;RigidBody&gt; bodies() {&#10;        return bodies;&#10;    }&#10;&#10;    public void addBody(RigidBody b) {&#10;        bodies.add(b);&#10;    }&#10;&#10;&#10;    /**&#10;     * Define o número de iterações do solver de contatos por substep. Mais iterações ajudam em empilhamentos estáveis&#10;     * (custo extra de CPU).&#10;     *&#10;     * @param iterations &gt;= 1&#10;     */&#10;    public void setSolverIterations(int iterations) {&#10;        this.solverIterations = Math.max(1, iterations);&#10;    }&#10;&#10;    /**&#10;     * Define o tamanho do passo fixo da simulação.&#10;     *&#10;     * @param step Tamanho do passo em segundos (ex: 1/120.0 para 120Hz).&#10;     */&#10;    public void setFixedTimeStep(double step) {&#10;        this.fixedTimeStep = Math.max(1e-6, step);&#10;    }&#10;&#10;    /**&#10;     * Define quantos substeps internos serão realizados para cada passo fixo.&#10;     * &lt;br&gt;&#10;     * Maior valor costuma reduzir penetração e jitter, mas custa performance.&#10;     *&#10;     * @param substeps Número de substeps (&gt;=1).&#10;     */&#10;    public void setSubsteps(int substeps) {&#10;        this.substeps = Math.max(1, substeps);&#10;    }&#10;&#10;&#10;    /**&#10;     * Define a estratégia de broadphase (ex.: new UniformGridBroadphase(cellSize)). Passe null para voltar ao&#10;     * brute-force O(n²).&#10;     */&#10;    public void setBroadphase(phys.broadphase.Broadphase bp) {&#10;        this.broadphase = bp;&#10;    }&#10;&#10;    /**&#10;     * Atualiza o mundo usando timestep fixo e substeps internos.&#10;     * &lt;br&gt;&#10;     * Faz clamp de deltaTime para evitar a &quot;espiral da morte&quot; quando há um spike de frame.&#10;     * &lt;br&gt;&#10;     * Limita o número de passos fixos por chamada.&#10;     *&#10;     * @param deltaTime Tempo real decorrido desde a última chamada (segundos).&#10;     */&#10;    public void update(double deltaTime) {&#10;        // clamp para evitar acumular tempo absurdo num frame travado&#10;        double maxDeltaTime = 0.25; // 250 ms; ajuste se quiser&#10;        double dt = Math.min(deltaTime, maxDeltaTime);&#10;&#10;        accumulator += dt;&#10;&#10;        int maxFixedStepsPerUpdate = 8; // evita laços longos demais por update&#10;        int steps = 0;&#10;&#10;        while (accumulator &gt;= fixedTimeStep &amp;&amp; steps &lt; maxFixedStepsPerUpdate) {&#10;            double subDt = fixedTimeStep / substeps;&#10;            for (int i = 0; i &lt; substeps; i++) {&#10;                step(subDt);&#10;            }&#10;            accumulator -= fixedTimeStep;&#10;            steps++;&#10;        }&#10;&#10;        // se estourou o máximo de passos, joga fora o excesso para manter a sim em dia&#10;        if (steps == maxFixedStepsPerUpdate) {&#10;            accumulator = 0.0;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Executa um único passo de simulação com tamanho de passo fixo.&#10;     * Ordem importante: integra -&gt; soft-contact -&gt; colisões -&gt; sleep.&#10;     */&#10;    public void step(double dt) {&#10;        Collision.setCurrentDt(dt);&#10;&#10;        // 0) Reset de atividade por corpo (para o sistema de sleep)&#10;        for (RigidBody b : bodies) {&#10;            b.beginStepActivityReset();&#10;        }&#10;        Collision.debugBeginStep();&#10;&#10;        // 1) Integra (corpos acordados)&#10;        for (RigidBody b : bodies) {&#10;            b.integrate(gravity, dt);&#10;        }&#10;&#10;        // 2) Broadphase → pares candidatos&#10;        java.util.List&lt;phys.broadphase.Broadphase.RigidBodyPair&gt; candidates;&#10;        if (broadphase != null) {&#10;            broadphase.clear();&#10;            double[] min = new double[3], max = new double[3];&#10;            for (RigidBody b : bodies) {&#10;                if (Bounds.compute(b, min, max)) {&#10;                    broadphase.insert(b, min, max);&#10;                }&#10;            }&#10;            candidates = broadphase.computePairs();&#10;&#10;            // adiciona pares com planos (dinâmicos × planos)&#10;            java.util.List&lt;RigidBody&gt; planes = new java.util.ArrayList&lt;&gt;();&#10;            java.util.List&lt;RigidBody&gt; others = new java.util.ArrayList&lt;&gt;();&#10;            for (RigidBody b : bodies) {&#10;                if (b.shape() instanceof Plane) planes.add(b);&#10;                else others.add(b);&#10;            }&#10;            for (RigidBody dyn : others) {&#10;                for (RigidBody pl : planes) {&#10;                    candidates.add(new phys.broadphase.Broadphase.RigidBodyPair(dyn, pl));&#10;                }&#10;            }&#10;        } else {&#10;            candidates = new java.util.ArrayList&lt;&gt;();&#10;            int n = bodies.size();&#10;            for (int i = 0; i &lt; n; i++) {&#10;                for (int j = i + 1; j &lt; n; j++) {&#10;                    candidates.add(new phys.broadphase.Broadphase.RigidBodyPair(bodies.get(i), bodies.get(j)));&#10;                }&#10;            }&#10;        }&#10;&#10;        // 3) PRIMEIRO: aplicar soft-contact para Sphere–Plane (limpa vₙ e faz snap)&#10;        for (var pair : candidates) {&#10;            var a = pair.a();&#10;            var b = pair.b();&#10;            if (a.isSleeping() &amp;&amp; b.isSleeping()) continue;&#10;&#10;            if (a.shape() instanceof Sphere &amp;&amp; b.shape() instanceof Plane) {&#10;                Collision.softContactSpherePlane(a, b);&#10;            } else if (b.shape() instanceof Sphere &amp;&amp; a.shape() instanceof Plane) {&#10;                Collision.softContactSpherePlane(b, a);&#10;            }&#10;        }&#10;&#10;        // 4) Agora sim: resolver colisões com múltiplas iterações&#10;        for (int iter = 0; iter &lt; solverIterations; iter++) {&#10;            for (var pair : candidates) {&#10;                var a = pair.a();&#10;                var b = pair.b();&#10;&#10;                if (a.isSleeping() &amp;&amp; b.isSleeping()) continue;&#10;&#10;                // Sphere–Sphere&#10;                var m1 = Collision.test(a, b);&#10;                if (m1 != null) { Collision.resolve(m1); continue; }&#10;&#10;                // Sphere–Plane&#10;                var m2 = Collision.testSpherePlane(a, b);&#10;                if (m2 != null) { Collision.resolve(m2); continue; }&#10;                var m3 = Collision.testSpherePlane(b, a);&#10;                if (m3 != null) { Collision.resolve(m3); continue; }&#10;&#10;                // Sphere–AABB&#10;                var m4 = Collision.testSphereAABB(a, b);&#10;                if (m4 != null) { Collision.resolve(m4); continue; }&#10;                var m5 = Collision.testSphereAABB(b, a);&#10;                if (m5 != null) { Collision.resolve(m5); continue; }&#10;&#10;                // AABB–Plane&#10;                var m6 = Collision.testAABBPlane(a, b);&#10;                if (m6 != null) { Collision.resolve(m6); continue; }&#10;                var m7 = Collision.testAABBPlane(b, a);&#10;                if (m7 != null) { Collision.resolve(m7); continue; }&#10;&#10;                // AABB–AABB&#10;                var m8 = Collision.testAABBAABB(a, b);&#10;                if (m8 != null) { Collision.resolve(m8); }&#10;            }&#10;        }&#10;&#10;        // 5) Sleep: thresholds de “silêncio” (pode manter estes)&#10;        double impulseQuiet = 1e-2;     // Ns&#10;        double correctionQuiet = 2e-3;  // m&#10;        for (RigidBody b : bodies) {&#10;            b.accumulateSleepTimer(dt, sleepVelThreshold, sleepTime, impulseQuiet, correctionQuiet);&#10;        }&#10;&#10;        // 6) LOG compacto a cada ~0.1s (se ligado)&#10;        if (DEBUG_SLEEP_LOGS) {&#10;            debugLogAccum += dt;&#10;            if (debugLogAccum &gt;= 0.1) {&#10;                System.out.printf(&quot;[SLEEPDBG] resolves=%d softContacts=%d bodies=%d%n&quot;,&#10;                    Collision.DEBUG_resolvesThisStep,&#10;                    Collision.DEBUG_softContactsThisStep,&#10;                    bodies.size());&#10;                for (RigidBody b : bodies) {&#10;                    String shape = b.shape().getClass().getSimpleName();&#10;                    double v = b.velocity().length();&#10;                    double vAvg = b.debugVelAvg();&#10;                    double timer = b.debugSleepTimer();&#10;                    boolean hc = b.hadContactThisStep();&#10;                    double j = b.maxImpulseThisStep();&#10;                    double corr = b.maxCorrectionThisStep();&#10;                    boolean sl = b.isSleeping();&#10;                    int id = System.identityHashCode(b);&#10;                    System.out.printf(&quot;  id=%08x %-6s y=%7.4f v=%7.4f vAvg=%7.4f timer=%5.3f contact=%s jMax=%7.5f corrMax=%7.5f sleeping=%s%n&quot;,&#10;                        id, shape, b.position().y(), v, vAvg, timer, hc, j, corr, sl);&#10;                }&#10;                debugLogAccum = 0.0;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Zera o acumulador de tempo do timestep fixo.&#10;     * &lt;br&gt;&#10;     * Útil ao pausar/despausar a simulação ou quando alterar drasticamente o relógio.&#10;     */&#10;    public void resetAccumulator() {&#10;        this.accumulator = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Retorna o fator de interpolação (0..1) representando a fração de tempo acumulada desde o último passo fixo. Útil&#10;     * para interpolar posições na camada de renderização.&#10;     * &lt;br&gt;&#10;     * Ex.: renderPos = lerp(prevPos, currPos, getInterpolationAlpha()).&#10;     */&#10;    public double getInterpolationAlpha() {&#10;        if (fixedTimeStep &lt;= 0.0) {&#10;            return 0.0;&#10;        }&#10;        double alpha = accumulator / fixedTimeStep;&#10;&#10;        if (alpha &lt; 0.0) {&#10;            return 0.0;&#10;        }&#10;&#10;        if (alpha &gt; 1.0) {&#10;            return 1.0;&#10;        }&#10;&#10;        return alpha;&#10;    }&#10;&#10;&#10;    /**&#10;     * Cria um corpo dinâmico do tipo esfera com centro em {@code pos} e raio {@code radius}.&#10;     *&#10;     * @param pos Centro da esfera&#10;     * @param radius Raio da esfera (&gt;0)&#10;     * @param mass Massa do corpo (&gt;0)&#10;     */&#10;    public static RigidBody dynamicSphere(Vec3 pos, double radius, double mass) {&#10;        return new RigidBody(pos, mass, new Sphere(radius));&#10;    }&#10;&#10;    /**&#10;     * Cria um corpo estático do tipo plano definido por uma normal {@code normal} e distância {@code d} do plano à&#10;     * origem (0,0,0).&#10;     * &lt;br&gt;&#10;     * O plano é definido pela equação n·x = d, onde n é a normal e x é um ponto no plano.&#10;     *&#10;     * @param normal Normal do plano (unitária)&#10;     * @param d Distância do plano à origem&#10;     */&#10;    public static RigidBody staticPlane(Vec3 normal, double d) {&#10;        return new RigidBody(new Vec3(0, 0, 0), 0.0, new Plane(normal, d));&#10;    }&#10;&#10;    /**&#10;     * Cria um corpo dinâmico do tipo AABB com centro em {@code pos}.&#10;     *&#10;     * @param pos centro&#10;     * @param halfExtents semi-eixos (hx, hy, hz)&#10;     * @param mass massa (&gt;0)&#10;     */&#10;    public static RigidBody dynamicBox(Vec3 pos, Vec3 halfExtents, double mass) {&#10;        return new RigidBody(pos, mass, new AABB(halfExtents));&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package phys.core;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import phys.broadphase.Broadphase;&#10;import phys.collision.AABB;&#10;import phys.collision.Collision;&#10;import phys.collision.Plane;&#10;import phys.collision.Sphere;&#10;import phys.math.Vec3;&#10;&#10;/**&#10; * Representa o mundo físico 3D, responsável por gerenciar corpos rígidos, gravidade, colisões,&#10; * integração temporal e sistema de sleep. Permite configuração de timestep fixo, substeps,&#10; * broadphase e parâmetros globais de repouso.&#10; */&#10;public final class World {&#10;    private final List&lt;RigidBody&gt; bodies = new ArrayList&lt;&gt;();&#10;    private Vec3 gravity = new Vec3(0, -9.81, 0);&#10;&#10;    // Novo controle de timestep fixo&#10;    private double fixedTimeStep = 1.0 / 120.0; // 120 Hz&#10;    private double accumulator = 0.0;&#10;    private int substeps = 1;&#10;    private int solverIterations = 4;&#10;    private Broadphase broadphase = null;&#10;    // --- Parâmetros globais de sleep ---&#10;    private double sleepVelThreshold = 0.05; // m/s&#10;    private double sleepTime = 0.5;          // s sob o limiar para dormir&#10;    // ==== DEBUG flags/estado (adicione no topo da classe World) ====&#10;    // Ligue/desligue logs compactos por step:&#10;    public static boolean DEBUG_SLEEP_LOGS = false;&#10;    private double debugLogAccum = 0.0;&#10;&#10;    /**&#10;     * Define o limiar de velocidade linear abaixo do qual o corpo é considerado &quot;parado&quot;.&#10;     *&#10;     * @param v Velocidade mínima (m/s) para considerar o corpo em movimento.&#10;     */&#10;    public void setSleepVelThreshold(double v) {&#10;        this.sleepVelThreshold = Math.max(0.0, v);&#10;    }&#10;&#10;    /**&#10;     * Define o tempo contínuo necessário (s) sob o limiar para entrar em sleep.&#10;     *&#10;     * @param seconds Tempo em segundos.&#10;     */&#10;    public void setSleepTime(double seconds) {&#10;        this.sleepTime = Math.max(0.0, seconds);&#10;    }&#10;&#10;    /**&#10;     * Define o vetor de gravidade global do mundo.&#10;     *&#10;     * @param g Vetor de gravidade.&#10;     */&#10;    public void setGravity(Vec3 g) {&#10;        this.gravity = g;&#10;        Collision.setGravity(g);&#10;    }&#10;&#10;    /**&#10;     * Retorna o vetor de gravidade atual do mundo.&#10;     *&#10;     * @return Vetor de gravidade.&#10;     */&#10;    public Vec3 gravity() {&#10;        return gravity;&#10;    }&#10;&#10;    /**&#10;     * Retorna a lista de corpos rígidos presentes no mundo.&#10;     *&#10;     * @return Lista de RigidBody.&#10;     */&#10;    public List&lt;RigidBody&gt; bodies() {&#10;        return bodies;&#10;    }&#10;&#10;    /**&#10;     * Adiciona um corpo rígido ao mundo.&#10;     *&#10;     * @param b Corpo a ser adicionado.&#10;     */&#10;    public void addBody(RigidBody b) {&#10;        bodies.add(b);&#10;    }&#10;&#10;&#10;    /**&#10;     * Define o número de iterações do solver de contatos por substep. Mais iterações ajudam em empilhamentos estáveis&#10;     * (custo extra de CPU).&#10;     *&#10;     * @param iterations &gt;= 1&#10;     */&#10;    public void setSolverIterations(int iterations) {&#10;        this.solverIterations = Math.max(1, iterations);&#10;    }&#10;&#10;    /**&#10;     * Define o tamanho do passo fixo da simulação.&#10;     *&#10;     * @param step Tamanho do passo em segundos (ex: 1/120.0 para 120Hz).&#10;     */&#10;    public void setFixedTimeStep(double step) {&#10;        this.fixedTimeStep = Math.max(1e-6, step);&#10;    }&#10;&#10;    /**&#10;     * Define quantos substeps internos serão realizados para cada passo fixo.&#10;     * &lt;br&gt;&#10;     * Maior valor costuma reduzir penetração e jitter, mas custa performance.&#10;     *&#10;     * @param substeps Número de substeps (&gt;=1).&#10;     */&#10;    public void setSubsteps(int substeps) {&#10;        this.substeps = Math.max(1, substeps);&#10;    }&#10;&#10;&#10;    /**&#10;     * Define a estratégia de broadphase (ex.: new UniformGridBroadphase(cellSize)). Passe null para voltar ao&#10;     * brute-force O(n²).&#10;     *&#10;     * @param bp Instância de Broadphase ou null.&#10;     */&#10;    public void setBroadphase(phys.broadphase.Broadphase bp) {&#10;        this.broadphase = bp;&#10;    }&#10;&#10;    /**&#10;     * Atualiza o mundo usando timestep fixo e substeps internos.&#10;     * &lt;br&gt;&#10;     * Faz clamp de deltaTime para evitar a &quot;espiral da morte&quot; quando há um spike de frame.&#10;     * &lt;br&gt;&#10;     * Limita o número de passos fixos por chamada.&#10;     *&#10;     * @param deltaTime Tempo real decorrido desde a última chamada (segundos).&#10;     */&#10;    public void update(double deltaTime) {&#10;        // clamp para evitar acumular tempo absurdo num frame travado&#10;        double maxDeltaTime = 0.25; // 250 ms; ajuste se quiser&#10;        double dt = Math.min(deltaTime, maxDeltaTime);&#10;&#10;        accumulator += dt;&#10;&#10;        int maxFixedStepsPerUpdate = 8; // evita laços longos demais por update&#10;        int steps = 0;&#10;&#10;        while (accumulator &gt;= fixedTimeStep &amp;&amp; steps &lt; maxFixedStepsPerUpdate) {&#10;            double subDt = fixedTimeStep / substeps;&#10;            for (int i = 0; i &lt; substeps; i++) {&#10;                step(subDt);&#10;            }&#10;            accumulator -= fixedTimeStep;&#10;            steps++;&#10;        }&#10;&#10;        // se estourou o máximo de passos, joga fora o excesso para manter a sim em dia&#10;        if (steps == maxFixedStepsPerUpdate) {&#10;            accumulator = 0.0;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Executa um único passo de simulação com tamanho de passo fixo.&#10;     * Ordem importante: integra -&gt; soft-contact -&gt; colisões -&gt; sleep.&#10;     *&#10;     * @param dt Tamanho do passo fixo (segundos).&#10;     */&#10;    public void step(double dt) {&#10;        phys.collision.Collision.setCurrentDt(dt);&#10;&#10;        // 0) Reset de atividade por corpo (para o sistema de sleep)&#10;        for (RigidBody b : bodies) {&#10;            b.beginStepActivityReset();&#10;        }&#10;        phys.collision.Collision.debugBeginStep();&#10;&#10;        // 1) Integra (corpos acordados)&#10;        for (RigidBody b : bodies) {&#10;            b.integrate(gravity, dt);&#10;        }&#10;&#10;        // 2) Broadphase → pares candidatos&#10;        java.util.List&lt;phys.broadphase.Broadphase.RigidBodyPair&gt; candidates;&#10;        if (broadphase != null) {&#10;            broadphase.clear();&#10;            double[] min = new double[3], max = new double[3];&#10;            for (RigidBody b : bodies) {&#10;                if (phys.collision.Bounds.compute(b, min, max)) {&#10;                    broadphase.insert(b, min, max);&#10;                }&#10;            }&#10;            candidates = broadphase.computePairs();&#10;&#10;            // adiciona pares com planos (dinâmicos × planos)&#10;            java.util.List&lt;RigidBody&gt; planes = new java.util.ArrayList&lt;&gt;();&#10;            java.util.List&lt;RigidBody&gt; others = new java.util.ArrayList&lt;&gt;();&#10;            for (RigidBody b : bodies) {&#10;                if (b.shape() instanceof phys.collision.Plane) planes.add(b);&#10;                else others.add(b);&#10;            }&#10;            for (RigidBody dyn : others) {&#10;                for (RigidBody pl : planes) {&#10;                    candidates.add(new phys.broadphase.Broadphase.RigidBodyPair(dyn, pl));&#10;                }&#10;            }&#10;        } else {&#10;            candidates = new java.util.ArrayList&lt;&gt;();&#10;            int n = bodies.size();&#10;            for (int i = 0; i &lt; n; i++) {&#10;                for (int j = i + 1; j &lt; n; j++) {&#10;                    candidates.add(new phys.broadphase.Broadphase.RigidBodyPair(bodies.get(i), bodies.get(j)));&#10;                }&#10;            }&#10;        }&#10;&#10;        // 3) PRIMEIRO: aplicar soft-contact para Sphere–Plane (limpa vₙ e faz snap)&#10;        for (var pair : candidates) {&#10;            var a = pair.a();&#10;            var b = pair.b();&#10;            if (a.isSleeping() &amp;&amp; b.isSleeping()) continue;&#10;&#10;            if (a.shape() instanceof phys.collision.Sphere &amp;&amp; b.shape() instanceof phys.collision.Plane) {&#10;                phys.collision.Collision.softContactSpherePlane(a, b);&#10;            } else if (b.shape() instanceof phys.collision.Sphere &amp;&amp; a.shape() instanceof phys.collision.Plane) {&#10;                phys.collision.Collision.softContactSpherePlane(b, a);&#10;            }&#10;        }&#10;&#10;        // 4) Agora sim: resolver colisões com múltiplas iterações&#10;        for (int iter = 0; iter &lt; solverIterations; iter++) {&#10;            for (var pair : candidates) {&#10;                var a = pair.a();&#10;                var b = pair.b();&#10;&#10;                if (a.isSleeping() &amp;&amp; b.isSleeping()) continue;&#10;&#10;                // Sphere–Sphere&#10;                var m1 = phys.collision.Collision.test(a, b);&#10;                if (m1 != null) { phys.collision.Collision.resolve(m1); continue; }&#10;&#10;                // Sphere–Plane&#10;                var m2 = phys.collision.Collision.testSpherePlane(a, b);&#10;                if (m2 != null) { phys.collision.Collision.resolve(m2); continue; }&#10;                var m3 = phys.collision.Collision.testSpherePlane(b, a);&#10;                if (m3 != null) { phys.collision.Collision.resolve(m3); continue; }&#10;&#10;                // Sphere–AABB&#10;                var m4 = phys.collision.Collision.testSphereAABB(a, b);&#10;                if (m4 != null) { phys.collision.Collision.resolve(m4); continue; }&#10;                var m5 = phys.collision.Collision.testSphereAABB(b, a);&#10;                if (m5 != null) { phys.collision.Collision.resolve(m5); continue; }&#10;&#10;                // AABB–Plane&#10;                var m6 = phys.collision.Collision.testAABBPlane(a, b);&#10;                if (m6 != null) { phys.collision.Collision.resolve(m6); continue; }&#10;                var m7 = phys.collision.Collision.testAABBPlane(b, a);&#10;                if (m7 != null) { phys.collision.Collision.resolve(m7); continue; }&#10;&#10;                // AABB–AABB&#10;                var m8 = phys.collision.Collision.testAABBAABB(a, b);&#10;                if (m8 != null) { phys.collision.Collision.resolve(m8); }&#10;            }&#10;        }&#10;&#10;        // 5) Sleep: thresholds de “silêncio” (pode manter estes)&#10;        double impulseQuiet = 1e-2;     // Ns&#10;        double correctionQuiet = 2e-3;  // m&#10;        for (RigidBody b : bodies) {&#10;            b.accumulateSleepTimer(dt, sleepVelThreshold, sleepTime, impulseQuiet, correctionQuiet);&#10;        }&#10;&#10;        // 6) LOG compacto a cada ~0.1s (se ligado)&#10;        if (DEBUG_SLEEP_LOGS) {&#10;            debugLogAccum += dt;&#10;            if (debugLogAccum &gt;= 0.1) {&#10;                System.out.printf(&quot;[SLEEPDBG] resolves=%d softContacts=%d bodies=%d%n&quot;,&#10;                    phys.collision.Collision.DEBUG_resolvesThisStep,&#10;                    phys.collision.Collision.DEBUG_softContactsThisStep,&#10;                    bodies.size());&#10;                for (RigidBody b : bodies) {&#10;                    String shape = b.shape().getClass().getSimpleName();&#10;                    double v = b.velocity().length();&#10;                    double vAvg = b.debugVelAvg();&#10;                    double timer = b.debugSleepTimer();&#10;                    boolean hc = b.hadContactThisStep();&#10;                    double j = b.maxImpulseThisStep();&#10;                    double corr = b.maxCorrectionThisStep();&#10;                    boolean sl = b.isSleeping();&#10;                    int id = System.identityHashCode(b);&#10;                    System.out.printf(&quot;  id=%08x %-6s y=%7.4f v=%7.4f vAvg=%7.4f timer=%5.3f contact=%s jMax=%7.5f corrMax=%7.5f sleeping=%s%n&quot;,&#10;                        id, shape, b.position().y(), v, vAvg, timer, hc, j, corr, sl);&#10;                }&#10;                debugLogAccum = 0.0;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Zera o acumulador de tempo do timestep fixo.&#10;     * &lt;br&gt;&#10;     * Útil ao pausar/despausar a simulação ou quando alterar drasticamente o relógio.&#10;     */&#10;    public void resetAccumulator() {&#10;        this.accumulator = 0.0;&#10;    }&#10;&#10;    /**&#10;     * Retorna o fator de interpolação (0..1) representando a fração de tempo acumulada desde o último passo fixo. Útil&#10;     * para interpolar posições na camada de renderização.&#10;     * &lt;br&gt;&#10;     * Ex.: renderPos = lerp(prevPos, currPos, getInterpolationAlpha()).&#10;     *&#10;     * @return Fator de interpolação (0 a 1).&#10;     */&#10;    public double getInterpolationAlpha() {&#10;        if (fixedTimeStep &lt;= 0.0) {&#10;            return 0.0;&#10;        }&#10;        double alpha = accumulator / fixedTimeStep;&#10;&#10;        if (alpha &lt; 0.0) {&#10;            return 0.0;&#10;        }&#10;&#10;        if (alpha &gt; 1.0) {&#10;            return 1.0;&#10;        }&#10;&#10;        return alpha;&#10;    }&#10;&#10;    /**&#10;     * Cria um corpo dinâmico do tipo esfera com centro em {@code pos} e raio {@code radius}.&#10;     *&#10;     * @param pos Centro da esfera&#10;     * @param radius Raio da esfera (&gt;0)&#10;     * @param mass Massa do corpo (&gt;0)&#10;     * @return Novo RigidBody dinâmico do tipo esfera.&#10;     */&#10;    public static RigidBody dynamicSphere(Vec3 pos, double radius, double mass) {&#10;        return new RigidBody(pos, mass, new Sphere(radius));&#10;    }&#10;&#10;    /**&#10;     * Cria um corpo estático do tipo plano definido por uma normal {@code normal} e distância {@code d} do plano à&#10;     * origem (0,0,0).&#10;     * &lt;br&gt;&#10;     * O plano é definido pela equação n·x = d, onde n é a normal e x é um ponto no plano.&#10;     *&#10;     * @param normal Normal do plano (unitária)&#10;     * @param d Distância do plano à origem&#10;     * @return Novo RigidBody estático do tipo plano.&#10;     */&#10;    public static RigidBody staticPlane(Vec3 normal, double d) {&#10;        return new RigidBody(new Vec3(0, 0, 0), 0.0, new Plane(normal, d));&#10;    }&#10;&#10;    /**&#10;     * Cria um corpo dinâmico do tipo AABB com centro em {@code pos}.&#10;     *&#10;     * @param pos centro&#10;     * @param halfExtents semi-eixos (hx, hy, hz)&#10;     * @param mass massa (&gt;0)&#10;     * @return Novo RigidBody dinâmico do tipo caixa (AABB).&#10;     */&#10;    public static RigidBody dynamicBox(Vec3 pos, Vec3 halfExtents, double mass) {&#10;        return new RigidBody(pos, mass, new AABB(halfExtents));&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/phys/math/Vec3.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/phys/math/Vec3.java" />
              <option name="originalContent" value="package phys.math;&#10;&#10;public record Vec3(double x, double y, double z) {&#10;&#10;    public static final Vec3 ZERO = new Vec3(0.0, 0.0, 0.0);&#10;&#10;    /**&#10;     * Soma este vetor com outro.&#10;     *&#10;     * @param o vetor a ser somado&#10;     * @return novo vetor resultado da soma&#10;     */&#10;    public Vec3 add(Vec3 o) {&#10;        return new Vec3(x + o.x, y + o.y, z + o.z);&#10;    }&#10;&#10;    public Vec3 sub(Vec3 o) {&#10;        return new Vec3(x - o.x, y - o.y, z - o.z);&#10;    }&#10;&#10;    public Vec3 mul(double s) {&#10;        return new Vec3(x * s, y * s, z * s);&#10;    }&#10;&#10;    public double dot(Vec3 o) {&#10;        return x * o.x + y * o.y + z * o.z;&#10;    }&#10;&#10;    public double length() {&#10;        return Math.sqrt(dot(this));&#10;    }&#10;&#10;    public Vec3 normalized() {&#10;        double len = length();&#10;        return (len == 0) ? this : this.mul(1.0 / len);&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package phys.math;&#10;&#10;/**&#10; * Representa um vetor 3D imutável com operações básicas de álgebra vetorial.&#10; *&#10; * @param x componente X&#10; * @param y componente Y&#10; * @param z componente Z&#10; */&#10;public record Vec3(double x, double y, double z) {&#10;&#10;    /**&#10;     * Vetor nulo (0,0,0).&#10;     */&#10;    public static final Vec3 ZERO = new Vec3(0.0, 0.0, 0.0);&#10;&#10;    /**&#10;     * Soma este vetor com outro.&#10;     *&#10;     * @param o vetor a ser somado&#10;     * @return novo vetor resultado da soma&#10;     */&#10;    public Vec3 add(Vec3 o) {&#10;        return new Vec3(x + o.x, y + o.y, z + o.z);&#10;    }&#10;&#10;    /**&#10;     * Subtrai outro vetor deste.&#10;     *&#10;     * @param o vetor a ser subtraído&#10;     * @return novo vetor resultado da subtração&#10;     */&#10;    public Vec3 sub(Vec3 o) {&#10;        return new Vec3(x - o.x, y - o.y, z - o.z);&#10;    }&#10;&#10;    /**&#10;     * Multiplica este vetor por um escalar.&#10;     *&#10;     * @param s escalar&#10;     * @return novo vetor escalado&#10;     */&#10;    public Vec3 mul(double s) {&#10;        return new Vec3(x * s, y * s, z * s);&#10;    }&#10;&#10;    /**&#10;     * Produto escalar entre este vetor e outro.&#10;     *&#10;     * @param o outro vetor&#10;     * @return valor do produto escalar&#10;     */&#10;    public double dot(Vec3 o) {&#10;        return x * o.x + y * o.y + z * o.z;&#10;    }&#10;&#10;    /**&#10;     * Retorna o comprimento (norma Euclidiana) deste vetor.&#10;     *&#10;     * @return comprimento do vetor&#10;     */&#10;    public double length() {&#10;        return Math.sqrt(dot(this));&#10;    }&#10;&#10;    /**&#10;     * Retorna uma cópia normalizada deste vetor (mesma direção, comprimento 1).&#10;     * Se o vetor for nulo, retorna ele mesmo.&#10;     *&#10;     * @return vetor normalizado&#10;     */&#10;    public Vec3 normalized() {&#10;        double len = length();&#10;        return (len == 0) ? this : this.mul(1.0 / len);&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>